---
title: 数组中的最长山脉
tags:
  - 数组中的最长山脉
sidebar: auto
---

### 数组中的最长山脉

::: tip 难度
中等
:::

![20201025](http://qiniu.gaowenju.com/leecode/banner/20201025.jpg)

## [题目:](https://leetcode-cn.com/problems/longest-mountain-in-array/)

我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “山脉”：

- B.length >= 3
- 存在 0 < i < B.length - 1 使得 B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]
  （注意：B 可以是 A 的任意子数组，包括整个数组 A。）

给出一个整数数组 A，返回最长 “山脉”  的长度。

如果不含有 “山脉”  则返回 0。

### 示例：

1. 示例 1：

```
输入：[2,1,4,7,3,2,5]
输出：5
解释：最长的 “山脉” 是 [1,4,7,3,2]，长度为 5。
```

2. 示例 2：

```
输入：[2,2,2]
输出：0
解释：不含 “山脉”。
```

**提示：**

- 0 <= A.length <= 10000
- 0 <= A[i] <= 10000

## 抛砖引玉

**思路：**

![抛砖引玉](http://qiniu.gaowenju.com/leecode/20201025.png)

```javascript
/**
 * @param {number[]} A
 * @return {number}
 */
var longestMountain = function(A) {
  let len = A.length,
    left = Array(n).fill(0),
    right = Array(n).fill(0),
    _result = 0
  if (len == 0) return 0
  for (let i = 1; i < n; ++i) {
    left[i] = A[i - 1] < A[i] ? left[i - 1] + 1 : 0
  }
  for (let i = n - 2; i >= 0; --i) {
    right[i] = A[i + 1] < A[i] ? right[i + 1] + 1 : 0
  }
  for (let i = 0; i < n; ++i) {
    if (left[i] > 0 && right[i] > 0) {
      _result = Math.max(_result, left[i] + right[i] + 1)
    }
  }
  return _result
}
```

```javascript
var longestMountain = function(A) {
  let len = A.length,
    _result = 0
  if (len == 0) return _result
  for (let i = 1; i < len - 1; i++) {
    if (A[i] > A[i - 1] && A[i] > A[i + 1]) {
      let index = i,
        num = 1
      while (A[index] > A[index - 1] && index > 0) {
        num++
        index--
      }
      index = i
      while (A[index] > A[index + 1] && index < len) {
        num++
        index++
      }
      _result = Math.max(_result, num)
    }
  }
  return _result
}
```
