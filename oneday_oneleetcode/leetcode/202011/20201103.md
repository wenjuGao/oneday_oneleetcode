---
title:  有效的山脉数组
tags:
  -  有效的山脉数组
sidebar: auto
---

###  有效的山脉数组

::: tip 难度
简单
:::

![20201103](http://qiniu.gaowenju.com/leecode/banner/20201103.jpg)

## [题目:](https://leetcode-cn.com/problems/valid-mountain-array/)

给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。

让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：

A.length >= 3
在 0 < i < A.length - 1 条件下，存在 i 使得：
- A[0] < A[1] < ... A[i-1] < A[i]
- A[i] > A[i+1] > ... > A[A.length - 1]

![有效的山脉数组](http://qiniu.gaowenju.com/leecode/20201103-01.png)

### 示例:

1. 示例1:

```
输入：[2,1]
输出：false
```

2. 示例2:

```
输入：[3,5,5]
输出：false
```

2. 示例2:

```
输入：[0,3,2,1]
输出：true
```

### 提示:

- 0 <= A.length <= 10000
- 0 <= A[i] <= 10000 

## 抛砖引玉

**思路：**

两次循环取出公共元素：
1. 循环第一个数组使用哈希记录其元素
2. 使用filter过滤第二个数组，在map中存在则保留(说明其实公共元素)否则不保留，返回过滤之后的结果

**注意：** 为了避免返回结果存在重复元素的问题，map中哈希均只能参与一次包含的判断，当map中哈希使用过就删除，避免后面相同元素同样能判断通过

![抛砖引玉](http://qiniu.gaowenju.com/leecode/20201103.png)

```javascript
/**
 * @param {number[]} A
 * @return {boolean}
 */
var validMountainArray = function(A) {
  let len = A.length,
  index = 0,
  maxIndex = 1
  if(len < 3) return false
  // 递增
  while(A[index] < A[maxIndex] && maxIndex < len){
    index++
    maxIndex++
  }
  index = maxIndex + 1
  // 递减
  while(A[index] < A[maxIndex] && index < len){
    index++
    maxIndex++
  }
  if(index == len -1) return true
  return false
};
```
