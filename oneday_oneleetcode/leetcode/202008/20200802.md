---
title: 最小区间
tags:
  - 最小区间
sidebar: auto
---

### 最小区间

::: tip 难度
中等
:::

![img](http://qiniu.gaowenju.com/leecode/banner/20200802.jpg)

## [题目:](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

给定一个二叉树，原地将它展开为一个单链表。

例如，给定二叉树

```
    1
   / \
  2   5
 / \   \
3   4   6
```
将其展开为：
```
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```


## 抛砖引玉

![img](http://qiniu.gaowenju.com/leecode/20200802.png)

**题意**
- 将二叉树的所有右节点放到根节点右侧上
- 放置顺序：先右后左即某节点同时存在左右节点时优先将左侧节点追加右侧

**思路**
- 递归展开左侧所有节点依次追加
- 展开的节点本事还包含其自身的子节点，需要重新定义节点的子节点
  - left -> null
  - right -> 需要追加的下一个右节点


```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {void} Do not return anything, modify root in-place instead.
 */
var flatten = function(root) {
    // 特殊情况：传入的二叉树为空直接返回
    if(!root||root.length===0){return root}

    let list = [];
    helper(root);
    //  遍历所有节点
    for (let i = 0; i < list.length - 1; i++) {
        let node = list[i],
            nextNode = list[i + 1];
        node.left = null;
        node.right = nextNode
    }

    // 收集节点
    function helper(node) {
        if (node !== null) {
            list.push(node);
            helper(node.left);
            helper(node.right);
        }
    }

};
```

### 其他解法

- 递归时已经遍历了所有节点
- 那么可以尝试不生成真实的list，在遍历是就拼接二叉树


```javascript
var flatten = function(root) {
    // 特殊情况：传入的二叉树为空直接返回
    if(!root||root.length===0){return root}

    // 记录上一个节点即本次要追加的到的位置
    let node = null;
    function helper(root){
        if (root !== null) {
            helper(root.right)
            helper(root.left)
            root.right = node
            root.left = null
            node = root
        }
    }
    helper(root)
}
```

```javascript
var flatten = function(root) {
    // 特殊情况：传入的二叉树为空直接返回
    if(!root||root.length===0){return root}

    helper(root);

    function helper(node){
        if(node !== null){

            let right = node.right, // 记录原right节点
                left = node.left; // 记录原left节点



 if (left) {               // 如果有左子树，生成单链表然后搬运过去
      let leftNode = helper(left); // 生成单链表，并获取头结点
      let leftLast = leftFirst;    // leftEnd是单链表的尾节点
      while (leftLast.right) {     // 一直找右节点，获取到单链表的尾节点
        leftLast = leftLast.right;
      }
      leftLast.right = root.right; // 尾节点后面接左子树展平后的单链表
      root.right = leftFirst;      // 根节点的right改成leftFirst
      root.left = null;            // root.left置为null
    }

                node.right = node.left; // 优先拼接left
                node.left = null;       // 清空left

            // 原left节点其子节点
            while(left.right){
                node=left.right;
            }
            node.right = right;
            helper(node.left);
            helper(node.right);  
            
            // let rightMost = node;
            // while(rightMost.right){
            //     rightMost=rightMost.right;
            // }
            // rightMost.right = right;
            // helper(node.left);
            // helper(node.right); 
        }
    }
    


  if(!root||root.length===0){return root}
    function helper(node){
        if(!node){return null}
        let oldRight=node.right;
        node.right=node.left;
        node.left=null;
        let rightMost=node;
        while(rightMost.right){
            rightMost=rightMost.right;
        }
        rightMost.right=oldRight;
        helper(node.left);
        helper(node.right);
    }
    helper(root);
    return root;



        let curr = root;
    while (curr !== null) {
        if (curr.left !== null) {
            const next = curr.left;
            let predecessor = next;
            while (predecessor.right !== null) {
                predecessor = predecessor.right;
            }
            predecessor.right = curr.right;
            curr.left = null;
            curr.right = next;
        }
        curr = curr.right;
    }

    return root;

};
```

```
const helper = (root) => {
        if (!root) {
            return
        }
        helper(root.right)
        helper(root.left)
        root.right = prev
        root.left = null
        prev = root
    }
    let prev = null
    helper(root)
```
