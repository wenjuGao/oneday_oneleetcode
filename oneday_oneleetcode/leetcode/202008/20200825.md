---
title: 递增子序列
tags:
  - 递增子序列
sidebar: auto
---

### 递增子序列

::: tip 难度
中等
:::

![20200825](http://qiniu.gaowenju.com/leecode/banner/20200825.jpg)

## [题目:](https://leetcode-cn.com/problems/increasing-subsequences/)

给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是 2。

### 示例

```
输入: [4, 6, 7, 7]
输出: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]
```

### 说明:

- 给定数组的长度不会超过 15。
- 数组中的整数范围是 [-100,100]。
- 给定数组中可能包含重复数字，相等的数字应该被视为递增的一种情况。

## 抛砖引玉

![抛砖引玉](http://qiniu.gaowenju.com/leecode/20200825.png)

### 暴力枚举

**思路：**
枚举数组的所有子集，判断是否递增

**实现：**

- 如果使用双侧循环枚举,那么枚举出来的子集需要逐个元素的去判断是否大于前一个元素
- 其实在枚举子元素时，一些子元素是会包含另外一些的，那么可以借助逐个关系来优化枚举的逻辑

因为子集的元素在原数组中可以是不相邻的，则不能使用指针来划分子集

声明数组 items 来作为中间子集，通过对数组元素的增加和删除来枚举原数组的子集：

1. 枚举起点，推入数组
2. 从起点开始逐个判断其是否小于中间数组 items 最后一个元素：
   - 大于等于放入 items
   - 小于不放入
   - 当还没从指定起点遍历到原数组末尾，中间数组就为空了，则重新推送起点元素
3. 判断当前的中间数组是否满足要求：
   - 满足则结果+1
   - 因为原数组中存在重复元素则枚举是可能会出现相同子集被重复统计，则需要记录以及统计过的满足条件的子集

**注意：**

- 中间子集在更换起点时需要重置；

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var findSubsequences = function (nums) {
  let _result = [],
    items = [],
    len = nums.length,
    map = new Map()

  dfs(0, items)

  function dfs(start, items) {
    if (items.length > 1) {
      let str = items.toString()
      if (map.has(str)) return
      _result.push(str.split(','))
      map.set(str)
    }
    for (let i = start; i < len; i++) {
      let last = items[items.length - 1]
      if (items.length == 0 || last <= nums[i]) {
        // 生成新的中间子集
        items.push(nums[i])
        // 校验子集
        dfs(i + 1, items)

        // 起点变更时，上个中间子集需要重置
        items.pop()
      }
    }
  }

  return _result
}
```

```java
class Solution {
    List<Integer> temp = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();

    public List<List<Integer>> findSubsequences(int[] nums) {
        dfs(0, Integer.MIN_VALUE, nums);
        return ans;
    }

    public void dfs(int cur, int last, int[] nums) {
        if (cur == nums.length) {
            if (temp.size() >= 2) {
                ans.add(new ArrayList<Integer>(temp));
            }
            return;
        }
        if (nums[cur] >= last) {
            temp.add(nums[cur]);
            dfs(cur + 1, nums[cur], nums);
            temp.remove(temp.size() - 1);
        }
        if (nums[cur] != last) {
            dfs(cur + 1, last, nums);
        }
    }
}
```

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
var findSubsequences = function (nums) {
  let _result = [],
    temp = []

  dfs(0, Number.MIN_VALUE, nums)

  function dfs(index, last, nums) {
    if (index === nums.length) {
      if (temp.length >= 2) {
        _result.push(temp.toString().split(','))
      }
      return
    }

    // 更新起点、子集最大元素
    if (nums[index] >= last) {
      temp.push(nums[index])
      dfs(index + 1, nums[index], nums)
      temp.pop()
    }
    //
    if (nums[index] != last) {
      dfs(index + 1, last, nums)
    }
  }

  return _result
}
```
