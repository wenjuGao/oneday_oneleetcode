---
title: 回文子串
tags:
  - 回文子串
sidebar: auto
---

### 回文子串

::: tip 难度
中等
:::

![20200819](http://qiniu.gaowenju.com/leecode/banner/20200819.jpg)

## [题目:](https://leetcode-cn.com/problems/palindromic-substrings/)

给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。

具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。

### 示例

1. 示例 1

```
输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
```

2. 示例 2

```
输入："aaa"
输出：6
解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa"
```

### 提示：

- 输入的字符串长度不会超过 1000 。

## 抛砖引玉

![抛砖引玉](http://qiniu.gaowenju.com/leecode/20200819.png)

**思路**

之前做过验证回文串的题目：
[20200619：验证回文串 (难度:简单)](../202006/20200619.md)
既然可以验证一个字符串是否为回文字符串了,那么就只剩枚举字符串的子区间了

```javascript
/**
 * @param {string} s
 * @return {number}
 */
var countSubstrings = function (s) {
  let _result = 0
  // 枚举区间
  for (let i = 0; i < s.length; i++) {
    for (let j = i; j < s.length; j++) {
      if (check(i, j + 1)) {
        _result++
      }
    }
  }
  return _result
  // 验证回文串
  function check(i, j) {
    let str = s
        .substring(i, j)
        .replace(/[^0-9a-zA-Z]/g, '')
        .toLowerCase(),
      n = str.length,
      left = 0,
      right = n - 1
    while (left < right) {
      if (str[left] != str[right]) {
        return false
      }
      left++
      right--
    }
    return true
  }
}
```

### 中心拓展

**通过区间来枚举可能是回文字符串中心位置的元素**

- 任何一个可能作为中心位置的元素，可能是唯一的中心也可能是与另外一个元素对称
  - 回文字符长度为奇数(唯一的中心)
  - 回文字符长度为偶数(与另外一个元素对称)
- 声明两个指针 left，right，来枚举中心位置
  中心位置的范围是：0-len-1，指针的范围是：0-2\*len-1

```javascript
var countSubstrings = function (s) {
  let len = s.length,
    _result = 0
  for (let i = 0; i < 2 * len - 1; ++i) {
    let left = parseInt(i / 2, 10),
      right = Math.ceil(i / 2)
    while (left >= 0 && right < len && s.charAt(left) === s.charAt(right)) {
      --left
      ++right
      ++_result
    }
  }
  return _result
}
```

### 动态规划

- 声明两个指针i,j
- dp[i][j]表示，区间i->j的回文字符数量
- 

```javascript
var countSubstrings = (s) => {
  let len = s.length,
    _result = 0,
    dp = rray(len);
  for (let i = 0; i < len; i++) {
    dp[i] = new Array(len).fill(false);
  }

  for (let j = 0; j < len; j++) {
    for (let i = 0; i <= j; i++) {
      if (i == j) { // 单个字符
        dp[i][j] = true;
        _result++;
      } else if (j - i == 1 && s[i] == s[j]) { // 两个字符 
        dp[i][j] = true;
        _result++;
      } else if (j - i > 1 && s[i] == s[j] && dp[i + 1][j - 1]) { // 多于两个字符
        dp[i][j] = true;
        _result++;
      }
    }
  }
  return _result;
};
```

### Manacher 算法

```javascript
var countSubstrings = function (s) {
  let n = s.length
  let t = ['$', '#']
  for (let i = 0; i < n; ++i) {
    t.push(s.charAt(i))
    t.push('#')
  }
  n = t.length
  t.push('!')
  t = t.join('')

  const f = new Array(n)
  let iMax = 0,
    rMax = 0,
    ans = 0
  for (let i = 1; i < n; ++i) {
    // 初始化 f[i]
    f[i] = i <= rMax ? Math.min(rMax - i + 1, f[2 * iMax - i]) : 1
    // 中心拓展
    while (t.charAt(i + f[i]) == t.charAt(i - f[i])) {
      ++f[i]
    }
    // 动态维护 iMax 和 rMax
    if (i + f[i] - 1 > rMax) {
      iMax = i
      rMax = i + f[i] - 1
    }
    // 统计答案, 当前贡献为 (f[i] - 1) / 2 上取整
    ans += Math.floor(f[i] / 2)
  }

  return ans
}
```
