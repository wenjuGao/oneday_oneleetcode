---
title: 最短回文串
tags:
  - 最短回文串
sidebar: auto
---

### 最短回文串

::: tip 难度
困难
:::

![20200829](http://qiniu.gaowenju.com/leecode/banner/20200829.jpg)

## [题目:](https://leetcode-cn.com/problems/shortest-palindrome/)

给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。

### 示例

1. 示例 1

```
输入: "aacecaaa"
输出: "aaacecaaa"
```

2. 示例 2

```
输入: "abcd"
输出: "dcbabcd"
```

## 抛砖引玉

![抛砖引玉](http://qiniu.gaowenju.com/leecode/20200829.png)

**思路**

字符拼接在字符前面，使字符变成回文字符。那么求当前字符从开始字符开始的最长回文字符，剩余的字符颠倒放到前面就成了完整的回文字符。

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var shortestPalindrome = function(s) {
  let len = s.length;
  // 从长到短求最长前缀回文字符
  for(let i = len;i >= 0;i--){
    let _result = s.substring(0,i);
    if(check(_result)){
      return Array.from(s.substring(i,len)).reverse().join('') + s
    }
  }
  // 校验是否为回文字符串
  function check(x) {
    let str = '' + x
    return Array.from(str).reverse().join('') === str
  }
};
```

在[day-23: 重复的子字符串 (难度:简单)](./20200823.md)中就用到了KMP算法去校验一个模式串是否匹配另外一个匹配串
- 将s和s字符颠倒str两个字符匹配，匹配上的部分则说明在s内部本事这两部是回文子串
- 在KMP算法中存在求最长公共前缀的逻辑（也是匹配时指针不连续跳转的序列），那么匹配时记录从哪个位置完成了匹配，
  则该位置之前的部分都是需要，补充完成才能形成回文字符非部分
- 最后的问题，补充的字符从哪里来呢，从s中，但是如果补充的部分字符顺序和s中相同则不能形成回文片段，则需要截取s的片段颠倒后再拼接

```javascript
/**
 * @param {string} s
 * @return {string}
 */
var shortestPalindrome = function(s) {
  let len = s.length,
      str = s.split('').reverse().join('');

  // 正反字符匹配求最长公共前缀的
  function kmp(query, pattern) {
    let fail = Array(len).fill(-1)
    // 最长公共前缀，不存在公共前缀填充-1
    for (let i = 1; i < len; ++i) {
      let j = fail[i - 1]
      while (j != -1 && pattern[j + 1] != pattern[i]) {
        j = fail[j]
      }
      if (pattern[j + 1] == pattern[i]) {
        fail[i] = j + 1
      }
    }
    // 校验  match记录匹配的位置
    let match = -1
    for (let i = 0; i < len; ++i) {
      // 如果当前不匹配匹配，指针跳跃到前缀位置开始匹配
      while (match != -1 && pattern[match + 1] != query[i]) {
        match = fail[match]
      }
      // 如果当前位匹配，逐个向后匹配，知道模式串匹配完成
      if (pattern[match + 1] == query[i]) {
        ++match
      }
    }
    return match
  }

  let num = kmp(str,s),
      add = (best == len - 1 ? "" : s.substring(best + 1));
  return Array.from(add).reverse().join('') + s;
};
```

