---
title: 冗余连接 II
tags:
  - 冗余连接 II
sidebar: auto
---

### 冗余连接 II

::: tip 难度
困难
:::

![20200917](http://qiniu.gaowenju.com/leecode/banner/20200917.jpg)

## [题目:](https://leetcode-cn.com/problems/redundant-connection-ii/)

在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。

输入一个有向图，该图由一个有着 N 个节点 (节点值不重复 1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在 1 到 N 中间，这条附加的边不属于树中已存在的边。

结果图是一个以边组成的二维数组。 每一个边 的元素是一对 [u, v]，用以表示有向图中连接顶点 u 和顶点 v 的边，其中 u 是 v 的一个父节点。

返回一条能删除的边，使得剩下的图是有 N 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。

### 示例：

1. 示例 1：

```
输入: [[1,2], [1,3], [2,3]]
输出: [2,3]
解释: 给定的有向图如下:
  1
 / \
v   v
2-->3
```

2. 示例 2：

```
输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]
输出: [4,1]
解释: 给定的有向图如下:
5 <- 1 -> 2
     ^    |
     |    v
     4 <- 3
```

**注意：**

- 二维数组大小的在 3 到 1000 范围内
- 二维数组中的每个整数在 1 到 N 之间，其中 N 是二维数组的大小。

## 抛砖引玉

![抛砖引玉](http://qiniu.gaowenju.com/leecode/20200917.png)

简化下题目：

每个节点都只有一个父节点(除根节点)的有向图叫做有根树，

给一个有根树增加一个多余的连接，找出当前这个有多余连接的有根树中最后出现的多余连接(不一定是添加的那个连接)

**思路**

添加多余连接造成的影响：

- 有根树没有了根节点(没有节点是无父节点的)
- 有根树中存在元素有多个父节点

此时会想到使用哈希记录每个节点的入度(其父节点连接其)出度(其连接其子节点)

那么问题就转换成了：

1. 如果每个节点都有父节点那怎么找出谁是根节点？
2. 有元素有多个父节点时，那个父节点是最后出现的？

使用数组 parent 记录每个节点的父节点 [1-N]

记录导致冲突的边、构成环路的边

<!-- [[2,1],[3,1],[4,2],[1,4]] -->
<!-- [[5,2],[5,1],[3,1],[3,4],[3,5]] -->
<!-- [[1,2],[1,3],[2,3],[1,4],[1,5]] -->

```javascript
/**
 * @param {number[][]} edges
 * @return {number[]}
 */
var findRedundantDirectedConnection = function(edges) {
  let startMap = new Map(),
    endMap = new Map()
  for (let i = 0; i < edges.length; i++) {
    if (startMap.has(edges[i][0])) {
      startMap.get(edges[i][0]).push(edges[i][1])
    } else {
      startMap.set(edges[i][0], [edges[i][1]])
    }
    if (endMap.has(edges[i][1])) {
      endMap.get(edges[i][1]).push(edges[i][0])
    } else {
      endMap.set(edges[i][1], [edges[i][0]])
    }
  }

  // 先循环终止endMap，查看是否是有多个父节点的情况，如果有多个父节点 返回后面那个节点
  for (let [key, value] of endMap) {
    if (value.length > 1) {
      return endMap.has(value[0]) ? [value[0], key] : [value[1], key]
    }
  }

  // 再循环开始startMap，查看是否是没有了父节点，如果是返回
  for (let [key, value] of startMap) {
    // 说明该点是原根节点
    if (value.length > 1) {
      return [endMap.get(key), key]
    }
  }
}
```

```javascript
/**
 * @param {number[][]} edges
 * @return {number[]}
 */
var findRedundantDirectedConnection = function(edges) {
  let len = edges.length,
    uf = Array(len + 1),
    parent = Array(len + 1),
    conflict = -1,
    cycle = -1

  for (let i = 0; i <= len; ++i) {
    if (i < len) uf[i] = i
    if (i > 0) parent[i] = i
  }

  function find(index) {
    if (uf[index] != index) {
      uf[index] = find(uf[index])
    }
    return uf[index]
  }

  for (let i = 0; i < len; ++i) {
    let edge = edges[i]
    let node1 = edge[0],
      node2 = edge[1]
    if (parent[node2] != node2) {
      conflict = i
    } else {
      parent[node2] = node1
      if (find(node1) == find(node2)) {
        cycle = i
      } else {
        uf[find(node1)] = find(node2)
      }
    }
  }
  if (conflict < 0) {
    return [edges[cycle][0], edges[cycle][1]]
  } else {
    let conflictEdge = edges[conflict]
    if (cycle >= 0) {
      return [parent[conflictEdge[1]], conflictEdge[1]]
    } else {
      return [conflictEdge[0], conflictEdge[1]]
    }
  }
}
```
