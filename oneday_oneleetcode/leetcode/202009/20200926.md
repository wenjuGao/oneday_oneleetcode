---
title: 路径总和 II
tags:
  - 路径总和 II
sidebar: auto
---

### 路径总和 II

::: tip 难度
中等
:::

![20200926](http://qiniu.gaowenju.com/leecode/banner/20200926.jpg)

## [题目:](https://leetcode-cn.com/problems/path-sum-ii/)

给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。

**说明:** 叶子节点是指没有子节点的节点。

**示例:**
给定如下二叉树，以及目标和 sum = 22，
```
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \    / \
        7    2  5   1
```

返回:

```
[
   [5,4,11,2],
   [5,8,4,5]
]
```

## 抛砖引玉

![抛砖引玉](http://qiniu.gaowenju.com/leecode/20200926.png)

**思路**

**思路**


```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {number[][]}
 */
var pathSum = function(root, sum) {
    let _result = []
    function dfs(node,item,num){
        if(node === null) {
            if(num === sum)_result.push(item)
            return
        }
        dfs(node.left,[...item,node.val],num+node.val)
        dfs(node.right,[...item,node.val],num+node.val)
    }
    dfs(root,[],0)
    return _result;
};
```


```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {number} sum
 * @return {number[][]}
 */
var pathSum = function(root, sum) {
    let _result = [],
        path = [];
    function dfs(node,num){
        if(node === null) {
            if(num === sum)_result.push([...path])
            return
        }
        path.push(node.val)
        dfs(node.left,num+node.val)
        dfs(node.right,num+node.val)
    }
    dfs(root,0)
    return _result;
};
```


```javascript
var pathSum = function(root, sum) {
    let _result = [],
        path = [];
    function dfs(node,num){
        if(node === null) return
        path.push(node.val)
        if(node.left === null && node.right === null && num+node.val === sum) _result.push([...path])
        dfs(node.left,num+node.val)
        dfs(node.right,num+node.val)
        path.pop();
    }
    dfs(root,0)
    return _result;
};
```