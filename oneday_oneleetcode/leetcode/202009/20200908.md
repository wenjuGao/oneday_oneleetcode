---
title: 组合
tags:
  - 组合
sidebar: auto
---

### 组合

::: tip 难度
中等
:::

![20200908](http://qiniu.gaowenju.com/leecode/banner/20200908.jpg)

## [题目:](https://leetcode-cn.com/problems/combinations/)

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

### 示例:

```
输入: n = 4, k = 2
输出:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]
```

## 抛砖引玉

![抛砖引玉](http://qiniu.gaowenju.com/leecode/20200908.png)

**思路**

从 n 中选择 k 个数

- 对于任意一个数存在选择和不选择两种情况，其中这两种情况有分别对应着不同的组合

递归：

- 参数：
  - 枚举分支的指针
  - 枚举分支的中间组合数组
- 终止：
  - 组合数组元素数量等于 k
  - 已选择未选择的数量不足 k

### 递归回溯

```javascript
/**
 * @param {number} n
 * @param {number} k
 * @return {number[][]}
 */
var combine = function (n, k) {
  let _result = []
  if (k === 0) return _result
  function dfs(i, item) {
    // 当已选择的元素和未选择的元素数量和不能到达k个则递归结束
    if (item.length + (n - i + 1) < k) return
    if (item.length === k) {
      _result.push(item)
      return
    }
    dfs(i + 1, [...item, i])
    dfs(i + 1, item)
  }

  dfs(1, [])
  return _result
}
```

### 非递归（字典序法）实现组合型枚举

二进制 1 代码选中，0 代表不选择，来表示选择组合

映射到数组元素的选择组合：

| 原序列中被选中的数 | 对应的二进制数 | 方案 | 方案    |
| ------------------ | -------------- | ---- | ------- |
| 43[2][1]           | 0011           | 1, 2 | [1,2,5] |
| 4[3]2[1]           | 0101           | 1, 3 | [1,3,5] |
| 4[3][2]            | 0110           | 3, 2 | [2,3,5] |
| [4]32[1]           | 1001           | 4, 1 | [1,4,5] |
| [4]3[2]1           | 1010           | 4, 2 | [2,4,5] |
| [4][3]21           | 1100           | 4, 3 | [3,4,5] |

可以发现：

开始的元素连续就重置成 1 开始，知道遇到不连续最后的元素+1，开始的元素不连续则直接+1

- 1、2 连续(两个 1 相邻)，2 与 5 不连续，则 2 递增
- 1、3、5 均不连续，则重置为 1 开始，第一个不连续点 1 递增
- 2、3 连续，与 5 不连续，则 2 重置为 1 开始，第一个不连续点 3 递增
- 1、4、5 均不连续，则重置为 1 开始，第一个不连续点 1 递增
- 2、4、5 均不连续，则重置为 1 开始，第一个不连续点 1 递增

* 1、2 连续(两个 1 相邻)，2 与 5 不连续，则 2 递增（第一个 1 向前移动）
* 1、3、5 均不连续，则第一个不连续点 1 递增（遇到 1 后出现 0 则向后面查找到 1 替换到紧邻的位置），注意此时移动修改元素，
* 2、3 连续，与 5 不连续，则

```javascript
var combine = function (n, k) {
  let item = [],
    _result = []
  // 初始化
  // 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k]
  // 末尾加一位 n + 1 作为哨兵
  for (let i = 1; i <= k; ++i) {
    item.push(i)
  }
  item.push(n + 1)

  let j = 0
  while (j < k) {
    _result.push(item.slice(0, k))
    j = 0
    // 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t
    // 我们需要把 [0, t - 1] 区间内的每个位置重置成 [1, t]
    while (j < k && item[j] + 1 == item[j + 1]) {
      item[j] = j + 1
      ++j
    }
    // j 是第一个 temp[j] + 1 != temp[j + 1] 的位置
    ++item[j]
  }
  return _result
}
```
