---
title: 前 K 个高频元素
tags:
  - 前 K 个高频元素
sidebar: auto
---

### 前 K 个高频元素

::: tip 难度
中等
:::

![20200907](http://qiniu.gaowenju.com/leecode/banner/20200907.jpg)

## [题目:](https://leetcode-cn.com/problems/top-k-frequent-elements/)

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

### 示例:

1. 示例 1

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

2. 示例 2

```
输入: nums = [1], k = 1
输出: [1]
```

## 抛砖引玉

![抛砖引玉](http://qiniu.gaowenju.com/leecode/20200907.png)

**思路**

- 遍历记录每个元素出现的次数
- 对数组去重且按照出现的次数排序
- 前 k 个元素就要求的结果

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function (nums, k) {
  let map = new Map(),
    arr = []
  for (let i = 0; i < nums.length; i++) {
    if (map.has(nums[i])) {
      let val = map.get(nums[i])
      map.set(nums[i], ++val)
    } else {
      map.set(nums[i], 1)
      arr.push(nums[i])
    }
  }
  let sortArr = arr.sort((a, b) => map.get(b) - map.get(a))
  return sortArr.splice(0, k)
}
```

### 堆

```javascript
var topKFrequent = function (nums, k) {
  let map = new Map(),
    heap = []

  for (let i = 0; i < nums.length; i++) {
    if (map.has(nums[i])) {
      let val = map.get(nums[i])
      map.set(nums[i], ++val)
    } else {
      map.set(nums[i], 1)
    }
  }

  if (map.size <= k) return [...map.keys()]

  for (let [key, value] of map) {
    let len = heap.length
    if (len < k) {
      heap.push(key)
      // 堆内放够k个元素后，对前k个元素堆化（即根据出现频率从小到大排列）
      if (len === k - 1) buildHeap(k)
    } else if (map.get(heap[0]) < value) {
      // 出现大于堆顶的元素则替换掉对顶，并且重新对新的堆排序
      heap[0] = key
      sortheap(k, 0)
    }
  }

  function buildHeap(k) {
    if (k === 1) return
    // 从最后一个非叶子节点开始，自上而下式堆化
    for (let i = parseInt(k / 2, 10); i >= 1; i--) {
      sortheap(i)
    }
  }
  // 对heap[i]重新排序
  function sortheap(i) {
    // 自上而下式堆化
    while (true) {
      let index = i
      if (2 * i <= k && map.get(heap[2 * i || 2]) < map.get(heap[i])) {
        index = 2 * i
      }
      if (2 * i + 1 <= k && map.get(heap[2 * i + 1]) < map.get(heap[index])) {
        index = 2 * i + 1
      }
      if (index !== i) {
        swap(heap, i, index)
        i = index
      } else {
        break
      }
    }
  }
  function swap(arr, i, j) {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
  }
  return heap
}
```

<!-- [4,1,-1,2,-1,2,3]
2 -->

### 基于快速排序
