---
title: 前 K 个高频元素
tags:
  - 前 K 个高频元素
sidebar: auto
---

### 前 K 个高频元素

::: tip 难度
中等
:::

![20200907](http://qiniu.gaowenju.com/leecode/banner/20200907.jpg)

## [题目:](https://leetcode-cn.com/problems/top-k-frequent-elements/)

给定一个非空的整数数组，返回其中出现频率前 k 高的元素。

### 示例:

1. 示例 1

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

2. 示例 2

```
输入: nums = [1], k = 1
输出: [1]
```

## 抛砖引玉

![抛砖引玉](http://qiniu.gaowenju.com/leecode/20200907.png)

**思路**

- 遍历记录每个元素出现的次数
- 对数组去重且按照出现的次数排序
- 前 k 个元素就要求的结果

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var topKFrequent = function (nums, k) {
  let map = new Map(),
    arr = []
  for (let i = 0; i < nums.length; i++) {
    if (map.has(nums[i])) {
      let val = map.get(nums[i])
      map.set(nums[i], ++val)
    } else {
      map.set(nums[i], 1)
      arr.push(nums[i])
    }
  }
  let sortArr = arr.sort((a, b) => map.get(b) - map.get(a))
  return sortArr.splice(0, k)
}
```

### 堆

```javascript
var topKFrequent = function (nums, k) {
  let map = new Map(),
    heap = [],
    arr = []

  for (let i = 0; i < nums.length; i++) {
    if (map.has(nums[i])) {
      let val = map.get(nums[i])
      map.set(nums[i], ++val)
    } else {
      map.set(nums[i], 1)
      arr.push(nums[i])
    }
  }

  if (map.size <= k) return arr

  for (let [key, value] of map) {
    if (heap.length < k) {
      heap.push(key)
      // 堆内放够k个元素后，对前k个元素堆化（即根据出现频率从小到大排列）
      buildHeapIn(heap.length - 1);
    } else if (map.get(heap[0]) < value) {
      // 出现大于堆顶的元素则替换掉对顶，并且重新对新的堆排序
      heap[0] = key
      buildHeapOut(0); 
    }
  }

  function buildHeapIn(x) {
    while (x > 0) {
      let y =  parseInt((x - 1)/2,10); 
      if (map.get(heap[y]) > map.get(heap[x])) { 
        swap(heap,y, x);
        x = y;
      } else {
        break;
      }
    }
  }

  function buildHeapOut(x) {
    while (2 * x + 1 < heap.length) {
      let y = 2 * x + 1;
      if (y + 1 < heap.length && map.get(heap[y+1]) < map.get(heap[y])) { 
        y++;
      }
      if ( map.get(heap[x]) > map.get(heap[y])) {
        swap(heap,x, y);
        x = y; 
      } else {
        break;
      }
    }
  }

  function swap(arr, i, j) {
    let temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
  }
  return heap.reverse()
}
```



### 基于快速排序

```javascript
/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
const topKFrequent = (nums, k) => {
  // 1. 设置哈希映射
  const keyValue = {};

  // 2. 遍历数组统计每个数字出现的次数
  for (let i = 0; i < nums.length; i++) {
    if (!keyValue[nums[i]]) {
      keyValue[nums[i]] = 0;
    }
    keyValue[nums[i]]++;
  }

  // 3. 如果元素数量小于等于 k，直接返回
  if (Object.keys(keyValue).length <= k) {
    return Object.keys(keyValue);
  }

  // 4. 如果大于 k，利用桶排序
  const bucket = [];
  // 4.1 遍历前面存储的哈希映射
  for (let key in keyValue) {
    // 4.2 如果该桶不存在，那就设置为空
    if (!bucket[keyValue[key]]) {
      bucket[keyValue[key]] = [];
    }
    // 4.3 往桶里添加，例如出现频率为 2 的，有 4 和 2，那就塞里面
    bucket[keyValue[key]].push(Number(key));
  }


  // 5. 统计结果
  const result = [];
  // 5.1 遍历桶，终止条件是 result 的长度小于 k
  for (let i = bucket.length - 1; i >= 0, result.length < k; i--) {
    // 5.1 如果该位置存在桶
    if (bucket[i]) {
      // 5.2 那么将桶里的东西提取出来放入结果
      for (let j = 0; j < bucket[i].length; j++) {
        result.push(bucket[i][j]);
      }
    }
  }

  // 6. 返回结果
  return result;
};
```