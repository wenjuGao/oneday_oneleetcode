---
title: 二叉树的后序遍历
tags:
  - 二叉树的后序遍历
sidebar: auto
---

### 二叉树的后序遍历

::: tip 难度
中等
:::

![20200929](http://qiniu.gaowenju.com/leecode/banner/20200929.jpg)

## [题目:](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)

给定一个二叉树，返回它的 后序 遍历。

```
输入: [1,null,2,3]
   1
    \
     2
    /
   3

输出: [3,2,1]
```

**进阶：**

递归算法很简单，你可以通过迭代算法完成吗？

## 抛砖引玉

![抛砖引玉](http://qiniu.gaowenju.com/leecode/20200929.png)

### 深度优先遍历（DFS）

**思路**
按照访问左子树——右子树——根节点的方式遍历这棵树

先用“很简单”的递归算法解决下吧

```javascript
/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var postorderTraversal = function(root) {
  if (root == null) return []
  let _result = []
  function dfs(node) {
    if (node === null) return
    if (node.left) dfs(node.left)
    if (node.right) dfs(node.right)
    _result.push(node.val)
  }
  dfs(root)
  return _result
}
```

### 广度优先遍历（BFS）

```javascript
var postorderTraversal = function(root) {
  if (root == null) return []
  let _result = [],
    queue = [root]
  while (queue.length) {
    let node = queue.pop()
    if (node) {
      queue.push(node)
      queue.push(null)
      if (node.right) queue.push(node.right)
      if (node.left) queue.push(node.left)
    } else {
      _result.push(queue.pop().val)
    }
  }
  return _result
}
```

```javascript
var postorderTraversal = function(root) {
  const res = []
  if (root === null) return res
  const stack = []
  stack.push(root.val, root.right, root.left)
  while (stack.length) {
    const item = stack.pop()

    if (item === null) {
      continue
    }

    if (typeof item === 'number') {
      res.push(item)
    } else {
      stack.push(item.val, item.right, item.left)
    }
  }

  return res
}
```

### Morris 遍历

```javascript
var postorderTraversal = function(root) {
  if (root == null) return []
  let _result = [],
    p1 = root,
    p2 = null

  while (p1 != null) {
    p2 = p1.left
    if (p2 != null) {
      while (p2.right != null && p2.right != p1) {
        p2 = p2.right
      }
      if (p2.right == null) {
        p2.right = p1
        p1 = p1.left
        continue
      } else {
        p2.right = null
        addPath(_result, p1.left)
      }
    }
    p1 = p1.right
  }
  addPath(_result, root)

  function addPath(_result, node) {
    let tmp = []
    while (node != null) {
      tmp.push(node.val)
      node = node.right
    }
    for (let i = tmp.length - 1; i >= 0; --i) {
      _result.push(tmp[i])
    }
  }

  return _result
}
```
