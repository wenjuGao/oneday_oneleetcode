---
title: 三角形最小路径和
tags:
  - 三角形最小路径和
sidebar: auto
---

### 三角形最小路径和

::: tip 难度
中等
:::

![img](http://qiniu.gaowenju.com/leecode/banner/20200714.jpg)

## [题目:](https://leetcode-cn.com/problems/triangle/)

给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。

**相邻的结点** 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。

例如，给定三角形：

```
[
     [2],
    [3,4],
   [6,5,7],
  [4,1,8,3]
]
```

自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。

### 说明

如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。

## 抛砖引玉

![img](http://qiniu.gaowenju.com/leecode/20200714.png)

- 啥也不说了就是干，先跑完所有的路线再求最小值
- 设 triangle 长 n，声明一个 nXn 的数组存放结果
- 对应位置存放到了该位置的和
- 循环最后一行找出最小值

```
[
  [2,0,0,0],
  [3,4,0,0],
  [6,5,7,0],
  [4,1,8,3]
]
=>
[
  [2,   0,        0,    0],
  [5,   6,        0,    0],
  [11,  (10,11),  13,   (0,6)],
  [...]
]
```

```javascript
/**
 * @param {number[][]} triangle
 * @return {number}
 */
var minimumTotal = function (triangle) {
  let n = triangle.length,
    dp = Array(n)
  // 声明nXn数组存放结果
  for (let i = 0; i < n; i++) {
    dp[i] = Array(n).fill(0)
  }
  // 放置初始值(第一步累加)
  dp[0][0] = triangle[0][0]

  for (let i = 1; i < n; ++i) {
    dp[i][0] = dp[i - 1][0] + triangle[i][0]
    for (let j = 1; j < i; ++j) {
      // 下一次下标(i)(j)相等 下一次下标减一(i)(j-1) 中去最小
      dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle[i][j]
    }
    //
    dp[i][i] = dp[i - 1][i - 1] + triangle[i][i]
  }
  let _result = dp[n - 1][0]
  for (let i = 1; i < n; ++i) {
    _result = Math.min(_result, dp[n - 1][i])
  }
  return _result
}
```

---

优化

---

### 空间优化

```javascript
/**
 * @param {number[][]} triangle
 * @return {number}
 */
var minimumTotal = function (triangle) {
  let dp = Array(triangle[triangle.length - 1].length)
  for (let i = 0; i < dp.length; i++) {
    dp[i] = triangle[triangle.length - 1][i]
  }
  for (let i = dp.length - 2; i >= 0; i--) {
    for (let j = 0; j < triangle[i].length; j++) {
      dp[j] = Math.min(dp[j], dp[j + 1]) + triangle[i][j]
    }
  }
  return dp[0]
}
```

### 时间优化

```javascript
/**
 * @param {number[][]} triangle
 * @return {number}
 */
var minimumTotal = function (triangle) {
  let n = triangle.length
  let dp = Array(n)
  for (let i = 0; i < n; i++) {
    dp[i] = Array(n).fill(0)
  }
  dp[0][0] = triangle[0][0]
  for (let i = 1; i < n; ++i) {
    let curr = i % 2
    let prev = 1 - curr
    dp[curr][0] = dp[prev][0] + triangle[i][0]
    for (let j = 1; j < i; ++j) {
      dp[curr][j] = Math.min(dp[prev][j - 1], dp[prev][j]) + triangle[i][j]
    }
    dp[curr][i] = dp[prev][i - 1] + triangle[i][i]
  }
  let _result = dp[(n - 1) % 2][0]
  for (let i = 1; i < n; ++i) {
    _result = Math.min(_result, dp[(n - 1) % 2][i])
  }
  return _result
}
```
