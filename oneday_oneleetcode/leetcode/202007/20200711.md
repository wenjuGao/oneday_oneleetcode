---
title: 计算右侧小于当前元素的个数
tags:
  - 计算右侧小于当前元素的个数
sidebar: auto
---

### 计算右侧小于当前元素的个数

::: tip 难度
困难
:::

![img](http://qiniu.gaowenju.com/leecode/banner/20200711.jpg)

## [题目:](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)

给定一个整数数组 nums，按要求返回一个新数组 counts。
数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。


### 示例

```
输入: [5,2,6,1]
输出: [2,1,1,0] 
解释:
5 的右侧有 2 个更小的元素 (2 和 1).
2 的右侧仅有 1 个更小的元素 (1).
6 的右侧有 1 个更小的元素 (1).
1 的右侧有 0 个更小的元素.
```

## 抛砖引玉

![img](http://qiniu.gaowenju.com/leecode/20200711.png)

### 暴力循环

- 声明一个存储结果的数组填充默认值0
- 逆向遍历输入数字
- 对每个数组指定循环之后的数统计比其小的数字个数存储到存储结果的数组中

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var countSmaller = function(nums) {
  let len = nums.length,
      _result = Array(len).fill(0);
  for(let i = len -1;i>=0;i--){
    _result[i] = get_num(i,nums,nums[i]);
  }
  function get_num(start,nums,n){
    let num = 0;
    if(start === nums.length-1) return num
    for(let i = start;i<=nums.length-1;i++){
      if(nums[i] < n)num++
    }
    return num
  }
  return _result
};
```

--- 
优化

- 减少重复遍历
- 


```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var countSmaller = function(nums) {
vector<int>t,res(nums.size());
　　　　　　/*初始化t,res*/
         for(int i=nums.size()-1;i>=0;i--){
             int left=0,right=t.size();
　　　　　　　　/*下面是一个在t数组里二分查找的过程*/
             while (left<right){
                 let mid=left+(right-left)/2;
                 if(t[mid]>=nums[i]){
                     right= mid;
                 }
                 else{
                     left=mid+1;
                 }
             }
             res[i]=right;
             t.insert(t.begin()+right,nums[i]);
         }
         return res;
};
```
