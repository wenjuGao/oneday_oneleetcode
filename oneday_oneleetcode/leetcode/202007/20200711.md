---
title: 计算右侧小于当前元素的个数
tags:
  - 计算右侧小于当前元素的个数
sidebar: auto
---

### 计算右侧小于当前元素的个数

::: tip 难度
困难
:::

![img](http://qiniu.gaowenju.com/leecode/banner/20200711.jpg)

## [题目:](https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/)

给定一个整数数组 nums，按要求返回一个新数组  counts。
数组 counts 有该性质： counts[i] 的值是   nums[i] 右侧小于  nums[i] 的元素的数量。

### 示例

```
输入: [5,2,6,1]
输出: [2,1,1,0]
解释:
5 的右侧有 2 个更小的元素 (2 和 1).
2 的右侧仅有 1 个更小的元素 (1).
6 的右侧有 1 个更小的元素 (1).
1 的右侧有 0 个更小的元素.
```

## 抛砖引玉

![img](http://qiniu.gaowenju.com/leecode/20200711.png)

### 暴力循环

- 声明一个存储结果的数组填充默认值 0
- 逆向遍历输入数字
- 对每个数组指定循环之后的数统计比其小的数字个数存储到存储结果的数组中

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var countSmaller = function (nums) {
  let len = nums.length,
    _result = Array(len).fill(0)
  for (let i = len - 1; i >= 0; i--) {
    _result[i] = get_num(i, nums, nums[i])
  }
  function get_num(start, nums, n) {
    let num = 0
    if (start === nums.length - 1) return num
    for (let i = start; i <= nums.length - 1; i++) {
      if (nums[i] < n) num++
    }
    return num
  }
  return _result
}
```

---

优化

- 求 i 右侧小于其的数
- 对右侧数据包括 i，排序找到 i 的位置，索引即要求的右侧小于它的数

```javascript
/**
 * @param {number[]} nums
 * @return {number[]}
 */
var countSmaller = function (nums) {
  let len = nums.length
  if (len == 0) return nums
  let _result = Array(len).fill(0)
  let sortList = []
  for (let i = len - 1; i >= 0; i--) {
    let index = findIndex(sortList, nums[i])
    sortList.splice(index, 0, nums[i])
    _result[i] = index
  }

  function findIndex(arr, target) {
    let lo = 0
    let hi = arr.length - 1
    while (lo < hi) {
      const mid = (lo + hi) >>> 1
      if (arr[mid] < target) {
        // 目标值比mid元素大，mid不是想要的
        lo = mid + 1 // 移到mid+1，lo是我最后想返回的
      } else {
        // 目标值小于等于mid元素
        hi = mid // mid可能是想要的，hi不能移到mid-1
      }
    }
    if (arr[lo] < target) return lo + 1 // 目标值比lo元素大，lo还需+1
    return lo // 否则 返回lo
  }

  return _result
}
```

### 其他解法

- 求 i 右侧小于其的数
- 设起点为 i，则对 i 到最后一个排序,nums[i]的索引就是有多少数小于他
